# -*- coding: utf-8 -*-
"""efficient_strat.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19K0sZ9KeTjsYky4qCOxzRPg_Acs0tl-L
"""

import numpy as np
import matplotlib.pyplot as plt
import numpy.random as npr
from scipy.stats import norm

import pandas as pd

r0 = 0.1
sigma = 0.3

# Calculate Euroupe call price
def call_price(K,S0,sigma,r=r0,T=1.0):
    v = sigma* np.sqrt(T)
    d1 = (np.log(S0/K)+r*T+v**2/2)/v
    d2 = d1-v
    return norm.cdf(d1)*S0-norm.cdf(d2)*K*np.exp(-r*T)

def delta_call(t,K,S,sigma=sigma,r=r0,T=1.0):
    v = sigma* np.sqrt(T-t)
    d1 = (np.log(S/K)+r*(T-t)+v**2/2)/v
    
    return norm.cdf(d1)

def Gamma_call(t,K,S,sigma=sigma,r=r0,T=1.0) :
    v = sigma* np.sqrt(T-t)
    d1 = (np.log(S/K)+r*(T-t)+v**2/2)/v
    
    return norm.pdf(d1)/(S*v)


def St(M=10000,S0=100,r=r0,T=1.0,sigma=sigma, N = 2001):
    t = T/(N-1)
    # initialisation of stock price
    st = np.exp(t*(np.ones((M,N)).cumsum(axis=1)-1)*(r-0.5*sigma**2))*S0
    Wt = npr.randn(M,N)*np.sqrt(t)
    Wt[:,0]=0
    Wt = Wt.cumsum(axis=1)
    st = st*np.exp(sigma*Wt)
    return st

def karandikar(St,K,threshold=0.03,r=0.1,T=1.0,sigma=0.3):
    M,N = St.shape
    dt = T/(N-1)
    NR = np.zeros(M) # number of rebalancing
    hedge_bs = np.ones(M)*call_price(K,St[0,0],sigma,r,T) # Hedging by Black-sholes
    hedge_ka = np.ones(M)*call_price(K,St[0,0],sigma,r,T) # Hedging by Karandikar
    
    delta_bs = delta_call(0,K,St[:,0])
    delta_ka = delta_call(0,K,St[:,0])
    
    last_price_bs = St[:,0]
    last_price_ka = St[:,0]
    
    NR_ka = np.zeros(M)
    
    
    for i in range(1,N-1):
        # Update standard BS hedging portfolio
        hedge_bs+=delta_bs*(St[:,i]-last_price_bs)
        delta_bs = delta_call(dt*i,K,St[:,i])
        last_price_bs = St[:,i]
        # Update Karandikar portfolio
        tmp = (np.abs(delta_bs-delta_ka)>=threshold)
        hedge_ka+=tmp*(St[:,i]-last_price_ka)*delta_ka
        delta_ka =tmp*delta_call(dt*i,K,St[:,i])+(1-tmp)*delta_ka
        last_price_ka=tmp*St[:,i]+(1-tmp)*last_price_ka
        NR_ka+=tmp
        #print(np.sum(np.abs(St[:,i]-last_price_ka)>=threshold))
     
    hedge_bs+=delta_bs*(St[:,-1]-last_price_bs)
    hedge_ka+=delta_ka*(St[:,-1]-last_price_ka)
    
    return hedge_bs-hedge_ka,NR_ka

def equidistant(St,K,nb=200,r=0.1,T=1.0,sigma=0.3):
    M,N = St.shape
    dt = T/(N-1)
    dn = int((N-1)/200) # number of rebalancing
    hedge_bs = np.ones(M)*call_price(K,St[0,0],sigma,r,T) # Hedging by Black-sholes
    hedge_eq = np.ones(M)*call_price(K,St[0,0],sigma,r,T) # Hedging by equidistant
    
    delta_bs = delta_call(0,K,St[:,0])
    delta_eq = delta_call(0,K,St[:,0])
    
    last_price_bs = St[:,0]
    last_price_eq = St[:,0]
    
    NR_eq = np.zeros(M)
    
    
    for i in range(1,N-1):
        # Update standard BS hedging portfolio
        hedge_bs+=delta_bs*(St[:,i]-last_price_bs)
        delta_bs = delta_call(dt*i,K,St[:,i])
        last_price_bs = St[:,i]
        # Update Karandikar portfolio
        if i%dn ==0:
          hedge_eq+=(St[:,i]-last_price_eq)*delta_eq
          delta_eq = delta_call(dt*i,K,St[:,i])
          last_price_eq = St[:,i]
          NR_eq +=1
          
    hedge_bs+=delta_bs*(St[:,-1]-last_price_bs)
    hedge_eq+=delta_eq*(St[:,-1]-last_price_eq)
    NR_eq +=1
    
    return hedge_bs-hedge_eq,NR_eq

def Masaaki(St,K,hn=0.05,r=r0,T=1.0,sigma=sigma):
    M,N = St.shape
    dt = T/(N-1)
    NR = np.zeros(M) # number of rebalancing
    hedge_bs = np.ones(M)*call_price(K,St[0,0],sigma,r,T) # Hedging by Black-sholes
    hedge_ma = np.ones(M)*call_price(K,St[0,0],sigma,r,T) # Hedging by Masaaki
    
    delta_bs = delta_call(0,K,St[:,0])
    delta_ma = delta_call(0,K,St[:,0])
    
    gamma_ma = Gamma_call(0,K,St[:,0])
    last_price_bs = St[:,0]
    last_price_ma = St[:,0]
    
    NR_ma = np.zeros(M)
    
    
    for i in range(1,N-1):
        # Update standard BS hedging portfolio
        hedge_bs+=delta_bs*(St[:,i]-last_price_bs)
        delta_bs = delta_call(dt*i,K,St[:,i])
        last_price_bs = St[:,i]
        # Update Massaki portfolio
        tmp = ((delta_bs-delta_ma)**2>=hn*gamma_ma)
        hedge_ma+=tmp*(St[:,i]-last_price_ma)*delta_ma
        delta_ma =tmp*delta_call(dt*i,K,St[:,i])+(1-tmp)*delta_ma
        gamma_ma =tmp*Gamma_call(dt*i,K,St[:,i])+(1-tmp)*gamma_ma
        last_price_ma=tmp*St[:,i]+(1-tmp)*last_price_ma
        
        #print(sum(gamma_ma))
        NR_ma+=tmp
        #print(np.sum(np.abs(St[:,i]-last_price_ka)>=threshold))
     
    hedge_bs+=delta_bs*(St[:,-1]-last_price_bs)
    hedge_ma+=delta_ma*(St[:,-1]-last_price_ma)
    
    return hedge_bs-hedge_ma,NR_ma

S = St()
plt.figure()
plt.plot(S[0])
plt.show()

karan,kn = karandikar(S,K=90)





K = np.arange(80,130,10)

n_k =[]
for k in K:
    n_k+=["K={}".format(k)]*9

methode_name =["Masaaki","Karandikar","Equidistant"]
names =[]
for s in methode_name:
    names+=[s]*3
names=names*len(K)

stat_names =['Z','N','C']*len(K)*3

arrarys = [n_k,names,stat_names]
tuples = list(zip(*arrarys))

index = pd.MultiIndex.from_tuples(tuples)
df = pd.DataFrame(np.zeros((len(K)*9,3)),columns=["mean","var","max(abs)"],index = index)




for k in K:
    ka,kn = karandikar(S,k)
    c_ka = ka*np.sqrt(kn)
    eq,en = equidistant(S,k)
    c_eq = eq*np.sqrt(en)
    ma,mn = Masaaki(S,k,hn=0.01)
    c_ma = ma*np.sqrt(mn)
    
    df.loc[("K={}".format(k),"Karandikar","Z"),:]=[ka.mean(),ka.var(),np.max(np.abs(ka))]
    df.loc[("K={}".format(k),"Karandikar","N"),:]=[kn.mean(),kn.var(),np.max(np.abs(kn))]
    df.loc[("K={}".format(k),"Karandikar","C"),:]=[c_ka.mean(),c_ka.var(),np.max(np.abs(c_ka))]

    df.loc[("K={}".format(k),"Masaaki","Z"),:]=[ma.mean(),ma.var(),np.max(np.abs(ma))]
    df.loc[("K={}".format(k),"Masaaki","N"),:]=[mn.mean(),mn.var(),np.max(np.abs(mn))]
    df.loc[("K={}".format(k),"Masaaki","C"),:]=[c_ma.mean(),c_ma.var(),np.max(np.abs(c_ma))]

    df.loc[("K={}".format(k),"Equidistant","Z"),:]=[eq.mean(),eq.var(),np.max(np.abs(eq))]
    df.loc[("K={}".format(k),"Equidistant","N"),:]=[en.mean(),en.var(),np.max(np.abs(en))]
    df.loc[("K={}".format(k),"Equidistant","C"),:]=[c_eq.mean(),c_eq.var(),np.max(np.abs(c_eq))]

print("Karan mean is ",karan.mean())
print("Karan var is ",karan.var())
print(kn.mean())
print((np.sqrt(kn)*karan).mean())

eq,en = equidistant(S,K=90)
print("Eq mean is ",eq.mean())
print("Eq var is ",eq.var())
print(en.mean())
print((np.sqrt(en)*eq).mean())

ma,mn = Masaaki(S,K=90,hn=0.01)
print("Ma mean is ",ma.mean())
print("Ma var is ",ma.var())
print(mn.mean())
print((np.sqrt(mn)*ma).mean())

df.to_csv("result.csv", encoding='utf-8',)
df.to_excel("output.xlsx") 
